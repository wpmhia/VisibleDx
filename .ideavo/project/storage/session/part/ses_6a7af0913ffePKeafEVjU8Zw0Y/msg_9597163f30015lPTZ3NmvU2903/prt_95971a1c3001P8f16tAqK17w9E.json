{
  "id": "prt_95971a1c3001P8f16tAqK17w9E",
  "messageID": "msg_9597163f30015lPTZ3NmvU2903",
  "sessionID": "ses_6a7af0913ffePKeafEVjU8Zw0Y",
  "type": "tool",
  "tool": "write",
  "callID": "toolu_01XubZVzLB4VqezXwpzXaGTy",
  "state": {
    "status": "completed",
    "input": {
      "filePath": "/home/user/project/components/ppg-camera.tsx",
      "content": "'use client'\n\nimport { useState, useRef, useEffect, useCallback } from 'react'\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card'\nimport { Button } from '@/components/ui/button'\nimport { Badge } from '@/components/ui/badge'\nimport { Alert, AlertDescription } from '@/components/ui/alert'\nimport { Camera, Heart, Pause, Play, AlertTriangle, CheckCircle } from 'lucide-react'\n\ninterface PPGCameraProps {\n  onHeartRateDetected: (heartRate: number) => void\n  isActive: boolean\n  onStatusChange?: (status: 'stopped' | 'starting' | 'detecting' | 'measuring') => void\n}\n\ninterface PPGSample {\n  timestamp: number\n  value: number\n}\n\nexport default function PPGCamera({ onHeartRateDetected, isActive, onStatusChange }: PPGCameraProps) {\n  const videoRef = useRef<HTMLVideoElement>(null)\n  const canvasRef = useRef<HTMLCanvasElement>(null)\n  const streamRef = useRef<MediaStream | null>(null)\n  const animationRef = useRef<number | null>(null)\n  const samplesRef = useRef<PPGSample[]>([])\n  const lastHeartRateRef = useRef<number>(0)\n  const measurementStartRef = useRef<number>(0)\n\n  const [isStarted, setIsStarted] = useState(false)\n  const [currentHeartRate, setCurrentHeartRate] = useState<number | null>(null)\n  const [fingerDetected, setFingerDetected] = useState(false)\n  const [error, setError] = useState<string | null>(null)\n  const [signalQuality, setSignalQuality] = useState<'poor' | 'fair' | 'good' | null>(null)\n\n  // PPG signal processing parameters\n  const SAMPLE_RATE = 30 // fps\n  const WINDOW_SIZE = 256 // samples for FFT analysis\n  const MIN_HR = 40\n  const MAX_HR = 200\n  const MEASUREMENT_DURATION = 10000 // 10 seconds minimum\n\n  const startCamera = useCallback(async () => {\n    try {\n      setError(null)\n      onStatusChange?.('starting')\n      \n      const stream = await navigator.mediaDevices.getUserMedia({\n        video: {\n          facingMode: 'user',\n          width: { ideal: 640 },\n          height: { ideal: 480 },\n          frameRate: { ideal: SAMPLE_RATE }\n        }\n      })\n\n      if (videoRef.current) {\n        videoRef.current.srcObject = stream\n        streamRef.current = stream\n        \n        videoRef.current.onloadedmetadata = () => {\n          videoRef.current?.play()\n          setIsStarted(true)\n          onStatusChange?.('detecting')\n          measurementStartRef.current = Date.now()\n          startProcessing()\n        }\n      }\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Camera access denied')\n      onStatusChange?.('stopped')\n    }\n  }, [onStatusChange])\n\n  const stopCamera = useCallback(() => {\n    if (animationRef.current) {\n      cancelAnimationFrame(animationRef.current)\n    }\n    \n    if (streamRef.current) {\n      streamRef.current.getTracks().forEach(track => track.stop())\n      streamRef.current = null\n    }\n    \n    setIsStarted(false)\n    setFingerDetected(false)\n    setCurrentHeartRate(null)\n    setSignalQuality(null)\n    samplesRef.current = []\n    onStatusChange?.('stopped')\n  }, [onStatusChange])\n\n  const processFrame = useCallback(() => {\n    const video = videoRef.current\n    const canvas = canvasRef.current\n    \n    if (!video || !canvas || video.videoWidth === 0) {\n      return\n    }\n\n    const ctx = canvas.getContext('2d')\n    if (!ctx) return\n\n    // Set canvas size to match video\n    canvas.width = video.videoWidth\n    canvas.height = video.videoHeight\n    \n    // Draw video frame to canvas\n    ctx.drawImage(video, 0, 0)\n    \n    // Get image data from center region (where finger should be)\n    const centerX = canvas.width / 2\n    const centerY = canvas.height / 2\n    const regionSize = Math.min(canvas.width, canvas.height) * 0.3\n    \n    const imageData = ctx.getImageData(\n      centerX - regionSize / 2,\n      centerY - regionSize / 2,\n      regionSize,\n      regionSize\n    )\n    \n    // Calculate average red channel intensity (PPG signal)\n    let redSum = 0\n    let brightness = 0\n    const pixels = imageData.data\n    \n    for (let i = 0; i < pixels.length; i += 4) {\n      redSum += pixels[i] // Red channel\n      brightness += (pixels[i] + pixels[i + 1] + pixels[i + 2]) / 3\n    }\n    \n    const numPixels = pixels.length / 4\n    const avgRed = redSum / numPixels\n    const avgBrightness = brightness / numPixels\n    \n    // Finger detection based on brightness and red intensity\n    const fingerPresent = avgBrightness > 50 && avgBrightness < 200 && avgRed > 80\n    setFingerDetected(fingerPresent)\n    \n    if (fingerPresent) {\n      // Add sample to buffer\n      const sample: PPGSample = {\n        timestamp: Date.now(),\n        value: avgRed\n      }\n      \n      samplesRef.current.push(sample)\n      \n      // Keep only recent samples (last 10 seconds)\n      const cutoffTime = Date.now() - 10000\n      samplesRef.current = samplesRef.current.filter(s => s.timestamp > cutoffTime)\n      \n      // Process heart rate if we have enough samples\n      if (samplesRef.current.length > SAMPLE_RATE * 3) { // 3 seconds minimum\n        const heartRate = calculateHeartRate()\n        if (heartRate && heartRate !== lastHeartRateRef.current) {\n          setCurrentHeartRate(heartRate)\n          lastHeartRateRef.current = heartRate\n          \n          // Auto-record if measurement is stable and sufficient duration\n          const measurementDuration = Date.now() - measurementStartRef.current\n          if (measurementDuration > MEASUREMENT_DURATION && signalQuality === 'good') {\n            onHeartRateDetected(heartRate)\n            onStatusChange?.('measuring')\n          }\n        }\n      }\n    }\n  }, [onHeartRateDetected, onStatusChange, signalQuality])\n\n  const calculateHeartRate = useCallback((): number | null => {\n    const samples = samplesRef.current\n    if (samples.length < WINDOW_SIZE / 2) return null\n\n    // Get recent samples\n    const recentSamples = samples.slice(-WINDOW_SIZE)\n    if (recentSamples.length < 50) return null\n\n    // Apply simple moving average filter to smooth signal\n    const smoothed = recentSamples.map((_, i) => {\n      const windowStart = Math.max(0, i - 2)\n      const windowEnd = Math.min(recentSamples.length, i + 3)\n      const windowSamples = recentSamples.slice(windowStart, windowEnd)\n      return windowSamples.reduce((sum, s) => sum + s.value, 0) / windowSamples.length\n    })\n\n    // Find peaks in the smoothed signal\n    const peaks: number[] = []\n    const threshold = Math.max(...smoothed) * 0.6\n    \n    for (let i = 2; i < smoothed.length - 2; i++) {\n      if (smoothed[i] > threshold &&\n          smoothed[i] > smoothed[i - 1] &&\n          smoothed[i] > smoothed[i - 2] &&\n          smoothed[i] > smoothed[i + 1] &&\n          smoothed[i] > smoothed[i + 2]) {\n        // Ensure minimum distance between peaks\n        if (peaks.length === 0 || i - peaks[peaks.length - 1] > SAMPLE_RATE / 4) {\n          peaks.push(i)\n        }\n      }\n    }\n\n    if (peaks.length < 3) {\n      setSignalQuality('poor')\n      return null\n    }\n\n    // Calculate intervals between peaks\n    const intervals: number[] = []\n    for (let i = 1; i < peaks.length; i++) {\n      const sampleInterval = peaks[i] - peaks[i - 1]\n      const timeInterval = (sampleInterval / SAMPLE_RATE) * 1000 // ms\n      intervals.push(timeInterval)\n    }\n\n    // Calculate average interval and heart rate\n    const avgInterval = intervals.reduce((sum, interval) => sum + interval, 0) / intervals.length\n    const heartRate = Math.round(60000 / avgInterval) // BPM\n\n    // Validate heart rate range\n    if (heartRate < MIN_HR || heartRate > MAX_HR) {\n      setSignalQuality('poor')\n      return null\n    }\n\n    // Assess signal quality based on interval consistency\n    const intervalStdDev = Math.sqrt(\n      intervals.reduce((sum, interval) => sum + Math.pow(interval - avgInterval, 2), 0) / intervals.length\n    )\n    \n    const coefficientOfVariation = intervalStdDev / avgInterval\n    \n    if (coefficientOfVariation < 0.1) {\n      setSignalQuality('good')\n    } else if (coefficientOfVariation < 0.2) {\n      setSignalQuality('fair')\n    } else {\n      setSignalQuality('poor')\n    }\n\n    return heartRate\n  }, [])\n\n  const startProcessing = useCallback(() => {\n    const process = () => {\n      processFrame()\n      animationRef.current = requestAnimationFrame(process)\n    }\n    process()\n  }, [processFrame])\n\n  useEffect(() => {\n    if (isActive && !isStarted) {\n      startCamera()\n    } else if (!isActive && isStarted) {\n      stopCamera()\n    }\n  }, [isActive, isStarted, startCamera, stopCamera])\n\n  useEffect(() => {\n    return () => {\n      stopCamera()\n    }\n  }, [stopCamera])\n\n  const manualRecord = () => {\n    if (currentHeartRate) {\n      onHeartRateDetected(currentHeartRate)\n      onStatusChange?.('measuring')\n    }\n  }\n\n  return (\n    <Card className=\"w-full\">\n      <CardHeader>\n        <CardTitle className=\"flex items-center gap-2\">\n          <Camera className=\"h-5 w-5\" />\n          Camera PPG Heart Rate\n        </CardTitle>\n        <CardDescription>\n          Place your fingertip gently over the camera lens with flashlight on\n        </CardDescription>\n      </CardHeader>\n      <CardContent className=\"space-y-4\">\n        {error && (\n          <Alert variant=\"destructive\">\n            <AlertTriangle className=\"h-4 w-4\" />\n            <AlertDescription>{error}</AlertDescription>\n          </Alert>\n        )}\n\n        <div className=\"relative\">\n          <video\n            ref={videoRef}\n            className=\"w-full max-w-md mx-auto rounded-lg border\"\n            style={{ transform: 'scaleX(-1)' }} // Mirror the video\n            playsInline\n            muted\n          />\n          <canvas\n            ref={canvasRef}\n            className=\"hidden\"\n          />\n          \n          {isStarted && (\n            <div className=\"absolute inset-0 flex items-center justify-center pointer-events-none\">\n              <div className=\"w-24 h-24 border-2 border-white rounded-full opacity-50\" />\n            </div>\n          )}\n        </div>\n\n        <div className=\"grid grid-cols-2 gap-4\">\n          <div className=\"text-center\">\n            <Badge variant={fingerDetected ? \"default\" : \"secondary\"} className=\"mb-2\">\n              {fingerDetected ? (\n                <>\n                  <CheckCircle className=\"h-3 w-3 mr-1\" />\n                  Finger Detected\n                </>\n              ) : (\n                \"Place Finger\"\n              )}\n            </Badge>\n          </div>\n          \n          <div className=\"text-center\">\n            {signalQuality && (\n              <Badge \n                variant={signalQuality === 'good' ? 'default' : signalQuality === 'fair' ? 'secondary' : 'destructive'}\n                className=\"mb-2\"\n              >\n                Signal: {signalQuality}\n              </Badge>\n            )}\n          </div>\n        </div>\n\n        {currentHeartRate && (\n          <div className=\"text-center p-4 bg-green-50 rounded-lg\">\n            <div className=\"flex items-center justify-center gap-2 mb-2\">\n              <Heart className=\"h-5 w-5 text-red-500\" />\n              <span className=\"text-2xl font-bold text-green-900\">\n                {currentHeartRate} BPM\n              </span>\n            </div>\n            <Button \n              onClick={manualRecord}\n              disabled={!fingerDetected || signalQuality === 'poor'}\n              size=\"sm\"\n            >\n              Record Reading\n            </Button>\n          </div>\n        )}\n\n        <Alert>\n          <AlertTriangle className=\"h-4 w-4\" />\n          <AlertDescription className=\"text-sm\">\n            <strong>Instructions:</strong>\n            <br />• Turn on your device's flashlight\n            <br />• Gently place fingertip over camera lens\n            <br />• Stay still and breathe normally\n            <br />• Wait for stable reading (10+ seconds)\n          </AlertDescription>\n        </Alert>\n      </CardContent>\n    </Card>\n  )\n}"
    },
    "output": "",
    "metadata": {
      "diagnostics": {},
      "filepath": "/home/user/project/components/ppg-camera.tsx",
      "exists": false
    },
    "title": "components/ppg-camera.tsx",
    "time": {
      "start": 1758142286375,
      "end": 1758142286404
    }
  }
}