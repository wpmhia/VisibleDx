{
  "id": "prt_962fc3dc10015BKbmRYrWhzgzx",
  "messageID": "msg_962fba899001VkzocRY6Po1psD",
  "sessionID": "ses_6a7af0913ffePKeafEVjU8Zw0Y",
  "type": "tool",
  "tool": "read",
  "callID": "toolu_01UPfM33ytFvboPwM3cB8TBu",
  "state": {
    "status": "completed",
    "input": {
      "filePath": "/home/user/project/components/ppg-camera.tsx"
    },
    "output": "<file>\n00001| 'use client'\n00002| \n00003| import { useState, useRef, useEffect, useCallback } from 'react'\n00004| import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card'\n00005| import { Button } from '@/components/ui/button'\n00006| import { Badge } from '@/components/ui/badge'\n00007| import { Alert, AlertDescription } from '@/components/ui/alert'\n00008| import { Camera, Heart, Pause, Play, AlertTriangle, CheckCircle } from 'lucide-react'\n00009| import { useTranslation } from '@/lib/language-context'\n00010| \n00011| interface PPGCameraProps {\n00012|   onHeartRateDetected: (heartRate: number) => void\n00013|   isActive: boolean\n00014|   onStatusChange?: (status: 'stopped' | 'starting' | 'detecting' | 'measuring') => void\n00015| }\n00016| \n00017| interface PPGSample {\n00018|   timestamp: number\n00019|   value: number\n00020| }\n00021| \n00022| export default function PPGCamera({ onHeartRateDetected, isActive, onStatusChange }: PPGCameraProps) {\n00023|   const { t } = useTranslation()\n00024|   const videoRef = useRef<HTMLVideoElement>(null)\n00025|   const canvasRef = useRef<HTMLCanvasElement>(null)\n00026|   const streamRef = useRef<MediaStream | null>(null)\n00027|   const animationRef = useRef<number | null>(null)\n00028|   const samplesRef = useRef<PPGSample[]>([])\n00029|   const lastHeartRateRef = useRef<number>(0)\n00030|   const measurementStartRef = useRef<number>(0)\n00031| \n00032|   const [isStarted, setIsStarted] = useState(false)\n00033|   const [currentHeartRate, setCurrentHeartRate] = useState<number | null>(null)\n00034|   const [fingerDetected, setFingerDetected] = useState(false)\n00035|   const [error, setError] = useState<string | null>(null)\n00036|   const [signalQuality, setSignalQuality] = useState<'poor' | 'fair' | 'good' | null>(null)\n00037| \n00038|   // PPG signal processing parameters\n00039|   const SAMPLE_RATE = 30 // fps\n00040|   const WINDOW_SIZE = 256 // samples for FFT analysis\n00041|   const MIN_HR = 40\n00042|   const MAX_HR = 200\n00043|   const MEASUREMENT_DURATION = 10000 // 10 seconds minimum\n00044| \n00045|   const startCamera = useCallback(async () => {\n00046|     try {\n00047|       setError(null)\n00048|       onStatusChange?.('starting')\n00049|       \n00050|       const stream = await navigator.mediaDevices.getUserMedia({\n00051|         video: {\n00052|           facingMode: 'user',\n00053|           width: { ideal: 640 },\n00054|           height: { ideal: 480 },\n00055|           frameRate: { ideal: SAMPLE_RATE }\n00056|         }\n00057|       })\n00058| \n00059|       if (videoRef.current) {\n00060|         videoRef.current.srcObject = stream\n00061|         streamRef.current = stream\n00062|         \n00063|         videoRef.current.onloadedmetadata = () => {\n00064|           videoRef.current?.play()\n00065|           setIsStarted(true)\n00066|           onStatusChange?.('detecting')\n00067|           measurementStartRef.current = Date.now()\n00068|           startProcessing()\n00069|         }\n00070|       }\n00071|     } catch (err) {\n00072|       setError(err instanceof Error ? err.message : t.ppgCamera.errors.cameraAccess)\n00073|       onStatusChange?.('stopped')\n00074|     }\n00075|   }, [onStatusChange])\n00076| \n00077|   const stopCamera = useCallback(() => {\n00078|     if (animationRef.current) {\n00079|       cancelAnimationFrame(animationRef.current)\n00080|     }\n00081|     \n00082|     if (streamRef.current) {\n00083|       streamRef.current.getTracks().forEach(track => track.stop())\n00084|       streamRef.current = null\n00085|     }\n00086|     \n00087|     setIsStarted(false)\n00088|     setFingerDetected(false)\n00089|     setCurrentHeartRate(null)\n00090|     setSignalQuality(null)\n00091|     samplesRef.current = []\n00092|     onStatusChange?.('stopped')\n00093|   }, [onStatusChange])\n00094| \n00095|   const processFrame = useCallback(() => {\n00096|     const video = videoRef.current\n00097|     const canvas = canvasRef.current\n00098|     \n00099|     if (!video || !canvas || video.videoWidth === 0) {\n00100|       return\n00101|     }\n00102| \n00103|     const ctx = canvas.getContext('2d')\n00104|     if (!ctx) return\n00105| \n00106|     // Set canvas size to match video\n00107|     canvas.width = video.videoWidth\n00108|     canvas.height = video.videoHeight\n00109|     \n00110|     // Draw video frame to canvas\n00111|     ctx.drawImage(video, 0, 0)\n00112|     \n00113|     // Get image data from center region (where finger should be)\n00114|     const centerX = canvas.width / 2\n00115|     const centerY = canvas.height / 2\n00116|     const regionSize = Math.min(canvas.width, canvas.height) * 0.3\n00117|     \n00118|     const imageData = ctx.getImageData(\n00119|       centerX - regionSize / 2,\n00120|       centerY - regionSize / 2,\n00121|       regionSize,\n00122|       regionSize\n00123|     )\n00124|     \n00125|     // Calculate average red channel intensity (PPG signal)\n00126|     let redSum = 0\n00127|     let brightness = 0\n00128|     const pixels = imageData.data\n00129|     \n00130|     for (let i = 0; i < pixels.length; i += 4) {\n00131|       redSum += pixels[i] // Red channel\n00132|       brightness += (pixels[i] + pixels[i + 1] + pixels[i + 2]) / 3\n00133|     }\n00134|     \n00135|     const numPixels = pixels.length / 4\n00136|     const avgRed = redSum / numPixels\n00137|     const avgBrightness = brightness / numPixels\n00138|     \n00139|     // Finger detection based on brightness and red intensity\n00140|     const fingerPresent = avgBrightness > 50 && avgBrightness < 200 && avgRed > 80\n00141|     setFingerDetected(fingerPresent)\n00142|     \n00143|     if (fingerPresent) {\n00144|       // Add sample to buffer\n00145|       const sample: PPGSample = {\n00146|         timestamp: Date.now(),\n00147|         value: avgRed\n00148|       }\n00149|       \n00150|       samplesRef.current.push(sample)\n00151|       \n00152|       // Keep only recent samples (last 10 seconds)\n00153|       const cutoffTime = Date.now() - 10000\n00154|       samplesRef.current = samplesRef.current.filter(s => s.timestamp > cutoffTime)\n00155|       \n00156|       // Process heart rate if we have enough samples\n00157|       if (samplesRef.current.length > SAMPLE_RATE * 3) { // 3 seconds minimum\n00158|         const heartRate = calculateHeartRate()\n00159|         if (heartRate && heartRate !== lastHeartRateRef.current) {\n00160|           setCurrentHeartRate(heartRate)\n00161|           lastHeartRateRef.current = heartRate\n00162|           \n00163|           // Auto-record if measurement is stable and sufficient duration\n00164|           const measurementDuration = Date.now() - measurementStartRef.current\n00165|           if (measurementDuration > MEASUREMENT_DURATION && signalQuality === 'good') {\n00166|             onHeartRateDetected(heartRate)\n00167|             onStatusChange?.('measuring')\n00168|           }\n00169|         }\n00170|       }\n00171|     }\n00172|   }, [onHeartRateDetected, onStatusChange, signalQuality])\n00173| \n00174|   const calculateHeartRate = useCallback((): number | null => {\n00175|     const samples = samplesRef.current\n00176|     if (samples.length < WINDOW_SIZE / 2) return null\n00177| \n00178|     // Get recent samples\n00179|     const recentSamples = samples.slice(-WINDOW_SIZE)\n00180|     if (recentSamples.length < 50) return null\n00181| \n00182|     // Apply simple moving average filter to smooth signal\n00183|     const smoothed = recentSamples.map((_, i) => {\n00184|       const windowStart = Math.max(0, i - 2)\n00185|       const windowEnd = Math.min(recentSamples.length, i + 3)\n00186|       const windowSamples = recentSamples.slice(windowStart, windowEnd)\n00187|       return windowSamples.reduce((sum, s) => sum + s.value, 0) / windowSamples.length\n00188|     })\n00189| \n00190|     // Find peaks in the smoothed signal\n00191|     const peaks: number[] = []\n00192|     const threshold = Math.max(...smoothed) * 0.6\n00193|     \n00194|     for (let i = 2; i < smoothed.length - 2; i++) {\n00195|       if (smoothed[i] > threshold &&\n00196|           smoothed[i] > smoothed[i - 1] &&\n00197|           smoothed[i] > smoothed[i - 2] &&\n00198|           smoothed[i] > smoothed[i + 1] &&\n00199|           smoothed[i] > smoothed[i + 2]) {\n00200|         // Ensure minimum distance between peaks\n00201|         if (peaks.length === 0 || i - peaks[peaks.length - 1] > SAMPLE_RATE / 4) {\n00202|           peaks.push(i)\n00203|         }\n00204|       }\n00205|     }\n00206| \n00207|     if (peaks.length < 3) {\n00208|       setSignalQuality('poor')\n00209|       return null\n00210|     }\n00211| \n00212|     // Calculate intervals between peaks\n00213|     const intervals: number[] = []\n00214|     for (let i = 1; i < peaks.length; i++) {\n00215|       const sampleInterval = peaks[i] - peaks[i - 1]\n00216|       const timeInterval = (sampleInterval / SAMPLE_RATE) * 1000 // ms\n00217|       intervals.push(timeInterval)\n00218|     }\n00219| \n00220|     // Calculate average interval and heart rate\n00221|     const avgInterval = intervals.reduce((sum, interval) => sum + interval, 0) / intervals.length\n00222|     const heartRate = Math.round(60000 / avgInterval) // BPM\n00223| \n00224|     // Validate heart rate range\n00225|     if (heartRate < MIN_HR || heartRate > MAX_HR) {\n00226|       setSignalQuality('poor')\n00227|       return null\n00228|     }\n00229| \n00230|     // Assess signal quality based on interval consistency\n00231|     const intervalStdDev = Math.sqrt(\n00232|       intervals.reduce((sum, interval) => sum + Math.pow(interval - avgInterval, 2), 0) / intervals.length\n00233|     )\n00234|     \n00235|     const coefficientOfVariation = intervalStdDev / avgInterval\n00236|     \n00237|     if (coefficientOfVariation < 0.1) {\n00238|       setSignalQuality('good')\n00239|     } else if (coefficientOfVariation < 0.2) {\n00240|       setSignalQuality('fair')\n00241|     } else {\n00242|       setSignalQuality('poor')\n00243|     }\n00244| \n00245|     return heartRate\n00246|   }, [])\n00247| \n00248|   const startProcessing = useCallback(() => {\n00249|     const process = () => {\n00250|       processFrame()\n00251|       animationRef.current = requestAnimationFrame(process)\n00252|     }\n00253|     process()\n00254|   }, [processFrame])\n00255| \n00256|   useEffect(() => {\n00257|     if (isActive && !isStarted) {\n00258|       startCamera()\n00259|     } else if (!isActive && isStarted) {\n00260|       stopCamera()\n00261|     }\n00262|   }, [isActive, isStarted, startCamera, stopCamera])\n00263| \n00264|   useEffect(() => {\n00265|     return () => {\n00266|       stopCamera()\n00267|     }\n00268|   }, [stopCamera])\n00269| \n00270|   const manualRecord = () => {\n00271|     if (currentHeartRate) {\n00272|       onHeartRateDetected(currentHeartRate)\n00273|       onStatusChange?.('measuring')\n00274|     }\n00275|   }\n00276| \n00277|   return (\n00278|     <Card className=\"w-full\">\n00279|       <CardHeader>\n00280|         <CardTitle className=\"flex items-center gap-2\">\n00281|           <Camera className=\"h-5 w-5\" />\n00282|           {t.ppgCamera.title}\n00283|         </CardTitle>\n00284|         <CardDescription>\n00285|           {t.ppgCamera.description}\n00286|         </CardDescription>\n00287|       </CardHeader>\n00288|       <CardContent className=\"space-y-4\">\n00289|         {error && (\n00290|           <Alert variant=\"destructive\">\n00291|             <AlertTriangle className=\"h-4 w-4\" />\n00292|             <AlertDescription>{error}</AlertDescription>\n00293|           </Alert>\n00294|         )}\n00295| \n00296|         <div className=\"relative\">\n00297|           <video\n00298|             ref={videoRef}\n00299|             className=\"w-full max-w-md mx-auto rounded-lg border\"\n00300|             style={{ transform: 'scaleX(-1)' }} // Mirror the video\n00301|             playsInline\n00302|             muted\n00303|           />\n00304|           <canvas\n00305|             ref={canvasRef}\n00306|             className=\"hidden\"\n00307|           />\n00308|           \n00309|           {isStarted && (\n00310|             <div className=\"absolute inset-0 flex items-center justify-center pointer-events-none\">\n00311|               <div className=\"w-24 h-24 border-2 border-white rounded-full opacity-50\" />\n00312|             </div>\n00313|           )}\n00314|         </div>\n00315| \n00316|         <div className=\"grid grid-cols-2 gap-4\">\n00317|           <div className=\"text-center\">\n00318|             <Badge variant={fingerDetected ? \"default\" : \"secondary\"} className=\"mb-2\">\n00319|               {fingerDetected ? (\n00320|                 <>\n00321|                   <CheckCircle className=\"h-3 w-3 mr-1\" />\n00322|                   {t.ppgCamera.fingerDetected}\n00323|                 </>\n00324|               ) : (\n00325|                 t.ppgCamera.placeFingerPrompt\n00326|               )}\n00327|             </Badge>\n00328|           </div>\n00329|           \n00330|           <div className=\"text-center\">\n00331|             {signalQuality && (\n00332|               <Badge \n00333|                 variant={signalQuality === 'good' ? 'default' : signalQuality === 'fair' ? 'secondary' : 'destructive'}\n00334|                 className=\"mb-2\"\n00335|               >\n00336|                 Signal: {t.ppgCamera.signalQuality[signalQuality]}\n00337|               </Badge>\n00338|             )}\n00339|           </div>\n00340|         </div>\n00341| \n00342|         {currentHeartRate && (\n00343|           <div className=\"text-center p-4 bg-green-50 rounded-lg\">\n00344|             <div className=\"flex items-center justify-center gap-2 mb-2\">\n00345|               <Heart className=\"h-5 w-5 text-red-500\" />\n00346|               <span className=\"text-2xl font-bold text-green-900\">\n00347|                 {currentHeartRate} BPM\n00348|               </span>\n00349|             </div>\n00350|             <Button \n00351|               onClick={manualRecord}\n00352|               disabled={!fingerDetected || signalQuality === 'poor'}\n00353|               size=\"sm\"\n00354|             >\n00355|               {t.ppgCamera.recordReading}\n00356|             </Button>\n00357|           </div>\n00358|         )}\n00359| \n00360|         <Alert>\n00361|           <AlertTriangle className=\"h-4 w-4\" />\n00362|           <AlertDescription className=\"text-sm\">\n00363|             <strong>Instructions:</strong>\n00364|             <br />• {t.ppgCamera.instructions.flashlight}\n00365|             <br />• {t.ppgCamera.instructions.placement}\n00366|             <br />• {t.ppgCamera.instructions.stillness}\n00367|             <br />• {t.ppgCamera.instructions.wait}\n00368|           </AlertDescription>\n00369|         </Alert>\n00370|       </CardContent>\n00371|     </Card>\n00372|   )\n00373| }\n</file>",
    "metadata": {
      "preview": "'use client'\n\nimport { useState, useRef, useEffect, useCallback } from 'react'\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card'\nimport { Button } from '@/components/ui/button'\nimport { Badge } from '@/components/ui/badge'\nimport { Alert, AlertDescription } from '@/components/ui/alert'\nimport { Camera, Heart, Pause, Play, AlertTriangle, CheckCircle } from 'lucide-react'\nimport { useTranslation } from '@/lib/language-context'\n\ninterface PPGCameraProps {\n  onHeartRateDetected: (heartRate: number) => void\n  isActive: boolean\n  onStatusChange?: (status: 'stopped' | 'starting' | 'detecting' | 'measuring') => void\n}\n\ninterface PPGSample {\n  timestamp: number\n  value: number\n}"
    },
    "title": "components/ppg-camera.tsx",
    "time": {
      "start": 1758302322650,
      "end": 1758302322652
    }
  }
}